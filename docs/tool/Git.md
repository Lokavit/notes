
```bash
$ git branch modal # 新建分支
$ git checkout modal # 切换分支
$ git status
$ git add .
$ git status
$ git checkout master # 切换到住分支
$ git merge modal # 提交分支

$ git push origin modal # 提交分支到远程

$ git fetch origin master # 下载最新的版本到origin/master分支上
$ git log -p master..origin/master # 比较本地的master分支和origin/master分支的差别
$ git merge origin/master # 最后进行合并

## 解决冲突之后
$ git status
$ git add .
$ git status
$ git commit -m "++"

## 合并到 master
$ git checkout master
$ git merge modal
$ git push origin

## 删除本地及远程分支
$ git branch -a # 查看所有分支
$ git branch -d router # 删除本地 router分支
$ git push origin --delete router # 删除远程 router分支
```
## Git 多仓库同步

```bash
# GitHub与局域网GitLab共享一个项目
# 在两个仓库里分别创建【空】项目[不含READMME.md文件]
# 本地建立 shiperp ,并初始化 git
$ cd git init
# 关联github远程仓库
$ git remote add lokavit https://github.com/Lokavit/shiperp.git
# 关联局域网gitlab远程仓库
$ git remote add satya http://局域网地址/frontend/shiperp.git
$ git remote -v # 查看远程仓库
# 新建一个 README.md文件
$ git status  git add .   git status
$ git commit -m "Add README.md"
$ git push lokavit master # 推送到 github的同名项目中
$ git push satya master # 推送到 gitlab的同名项目中
```

- 以下为其他情况，或许可以排错

```bash
# 在README.md里编辑一下
$ git status # 查看文件状态
$ git add . # 添加文件
$ git status # 查看暂存状态
$ git commit -m "Add Content 2" # 提交msg
$ git pull origin master # 拉去 origin 仓库主分支
$ git push origin master # 提交 origin 仓库主分支
$ git pull mirror master # 拉去 mirror 仓库主分支
$ git push mirror master # 提交 mirror 仓库主分支

## 其他错误处理
$ git pull mirror master --allow-unrelated-histories # 确定合并
```

```bash
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[remote "lokavit"]
	url = https://github.com/Lokavit/shiperp.git
	fetch = +refs/heads/*:refs/remotes/lokavit/*
[remote "satya"]
	url = http://局域网地址/frontend/shiperp.git
	fetch = +refs/heads/*:refs/remotes/satya/*
```

## gitBash 打开 VSCode

```Bash
# C:\Users\username/.bash_profile文件
# generated by Git for Windows
test -f ~/.profile && . ~/.profile
test -f ~/.bashrc && . ~/.bashrc

# OPEN Program 注意空格转义及斜线转义。
alias vscode="D:/\Program\ Files/\Microsoft\ VS\ Code/Code.exe"
# VUE
alias vue='winpty vue.cmd'
```

## 本地创建项目，连接远程仓库

在 Github 上創建一個空倉庫，亦可見到如下提示

```Bash
# GitHub上创建项目(空)仓库,本地创建项目
$ cd 项目根目录 # 进入项目根目录
$ git init # 初始化
$ git status # 查看文件状态
$ git add .  # 添加到暂存区
$ git status # 查看文件状态
$ git remote add origin 仓库地址 # 连接到远程仓库
$ git remote -v # 查看是否连接成功
$ git push -u origin master # 当前分支关联到远程分支
```

## git 多人协作

```Bash
$ git branch modal # 新建分支
$ git checkout modal # 切换分支
$ git status
$ git add .
$ git status
$ git checkout master # 切换到住分支
$ git merge modal # 提交分支

$ git push origin modal # 提交分支到远程

$ git fetch origin master # 下载最新的版本到origin/master分支上
$ git log -p master..origin/master # 比较本地的master分支和origin/master分支的差别
$ git merge origin/master # 最后进行合并

## 解决冲突之后
$ git status
$ git add .
$ git status
$ git commit -m "++"

## 合并到 master
$ git checkout master
$ git merge modal
$ git push origin

```

## git bash 使用 tree

```Bash
# 将tree.exe放入git.usr/bin中
$ tree -d # 显示目录名称而非内容
$ tree -L 3 # 指定层级
# 命令集，详见末尾
```

> warning: LF will be replaced by CRLF in ……………….

```Bash
$ git config --global core.autocrlf true # 当签出代码时，LF会被转换成CRLF (Win)
$ git config --global core.autocrlf input # 提交时把CRLF转换成LF(Mac Linux)
$ git config --global core.autocrlf false # 仅运行在Windows上的项目
```

## Git 拉取远程分支

```Bash
$ git init # 本地初始化
$ git remote add origin 仓库地址  # 连接远程仓库
$ git fetch origin dev # dev为远程仓库的分支名
# 在本地创建分支dev并切换到该分支
$ git checkout -b dev origin/dev
$ git pull origin dev # 拉取 git上dev分支上的内容
```

### Git 术语及名词解释

**Workspace**：工作区

- 通过 *git init*创建代码库的所有文件,不包含*.git*(版本库文件)

**Stage/Index**：暂存区/索引

- 通过*git add ./(地址)*添加修改;
- 通过*git status* 可以看到修改的状态.

**Repository**：仓库/本地存储库

**Remote**：远程仓库

**git status -s** 查看文件状态

- _??_：表示新添加未跟踪的文件
- _A _：表示新添加到暂存区中的文件
- _M _：表示修改过的文件
- _右 M_：表示该文件被修改但未放入暂存区;
- _左 M_：表示该文件被修改并放入暂存区;
- _双 M_：表示工作区修改并提交到暂存区后,又在工作区中被修改,所以左右皆有.
- _R _：表示该文件被重命名

### 基本操作流程

**常规提交-推送流程**

```Bash
$ git status  # 查看文件状态,确定是否全部以放入暂存区
$ git add .  # 将未放入暂存区的文件放入暂存区
$ git commit # 提交
$ git push  # 推送到远程仓库
```

**跳过暂存区提交流程**

```Bash
$ git status # 查看文件状态,确定是否全部以放入暂存区
$ git commit -a -m '更新说明'
```

**查看被打分支下的文件**

```Bash
$ ls # 查看当前目录下的所有文件夹及文件;
$ cd dir # 打开某文件夹,继续*ls*查看;
```

**删除文件**

```Bash
$ git rm FileName  # 删除指定文件名的文件
$ git rm FileName -r -f # 删除指定文件夹下所有文件
$ git status -s  # 确认文件状态
$ git commit -m 'DeleteFIle' # 提交版本的说明
$ git push  #  推送到远程仓库
```

**Git 操作目录**

```Bash
$ cd C:/ # 切换磁盘,
## === 进入带空格的目录=== ##
$ cd "Program Files" # 第一种：将文件名加上""
$ cd Program" "Files # 第二种：将空格加上""
```

### Git 常用命令

```Bash
$ git config --global user.name "yourname" # 配置全局用户信息
$ git config --global user.email 123@456.com # 配置全局用户信息

$ git config --list  # 查看配置信息

$ git config --global core.editor vim # 自定义编辑器

$ git helep # 查看帮助手册
$ git --help # 查看帮助手册

$ git help config # 查看config命令手册

$ git clone url(仓库地址) # 克隆仓库
$ git clone url(仓库地址) MyGit # 克隆仓库,自定义本地存储库的名字

$ git init #  初始化仓库 (该命令在需管理的本地存储库目录下执行)

$ git add Test.cs # 对文件跟踪 ,使文件处于暂存状态(允许该命令后再次修改的文件,需要再次允许该命令)
$ git commit -m 'Update Version'  # 提交,备注信息自定义

$ git status # 查看当前文件处于什么状态
$ git status -s # 查看当前文件状态(紧凑版)

$ git diff #  查看文件具体修改的地方(只显示尚未暂存的改动，而非自上次提交以来的所有改动。)
$ git diff --cached # 查看已经暂存起来的变化

$ git rm # 移除文件(将文件从暂存区中移除)
$ git rm log/\*.log # 删除log/目录下扩展名为.log的所有文件
$ git rm \*~   # 删除以 ~ 结尾的所有文件。

$ git mv file_from file_to #  文件重命名

$ git log  # 查看提交历史
$ git log -p # 显示每次提交的差异
$ git log -p -2 # 仅显示最近两次提交
$ git log --stat # 查看每次提交简略的统计信息
$ git log --pretty=online  # 将每个提交放在一行显示

$git commit --amend # 重新提交(将暂存区的文件提交,如未作修改,则只变更提交信息)

# 提交后发现忘记了暂存某些需要的修改
$ git commit -m 'Update commit'
$ git add (忘记的文件)
$ git commit --amend # 最终只有一个提交(第二次提交代替第一次提交的结果)

$ git reset HEAD my.txt # 取消暂存

$ git checkout -- my.txt # 撤销之前所做的更改


$ git remote  # 查看已配置的远程仓库服务器
$ git remote -v  # 显示需要读写远程仓库使用的Git保存的简写与其对应的URL

$ git remote add test url(远程仓库地址) # 添加新的远程仓库，并指定一个可以轻松引用的简写
# 此时,可以用 test 来代替 url

$ git fetch [remote-name] #  拉取远程仓库
$ git fetch test  #  拉取test的远程仓库

$ git pull  # 自动抓取后,合并远程分支到当前分支

$ git push [remote-name] [branch-name]  # 推送到远程仓库
$ git push origon master

```

---

## Git Bash 常用命令

### 文件夹操作

```Bash
$ mkdir 文件夹名  # 创建文件夹
$ mkdir 文件夹名 && cd 文件夹名  # 创建并打开文件夹
$ rm -r 文件夹名  # 删除文件夹
$ cd  # 切换到某目录下
$ cd ..  # 退回到上一目录
$ pwd  # 显示当前目录路径
$ ls  # 列出当前目录中所有文件
$ ll  # 列出当前目录所有文件，详细版
```

### 文件操作

```Bash
$ touch 文件名.后缀名  # 新建文件
$ rm 文件名.后缀名  # 删除文件
$ vi 文件名.后缀名  # 新建文件并进入编辑状态。
$ vi index.html encoding:utf8  # 创建文件指定编码格式
# 注：vi为linux文本编辑器,该命令实则进入vi程序。
默认为命令模式，按下 i 切换为编辑模式。
输入内容，按esc退出编辑模式, 按 :x 退出并保存，回到命令行界面。

$ mv 文件名.后缀名 目标文件夹
$ mv index.js src  # 表示把当前的index.js文件移动到src文件夹下

```

### 其它操作

```Bash
$ rest  # 清屏
```

## 在 Git Bash 中用某程序打开某文件

### 在 Git Bash 中用 Chrome 打开 index.html 文件

- 创建一个文件，命名为需要的命令，如 chrome(无后缀名)

```Bash
#!/bin/sh
"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe" $1 &

## 注释：
第一行表示这是一个shell脚本
第二行是chrome的装载目录
$1 取命令之后输入的参数
& 此命令在后台打开，不会阻塞git bash
```

- 将该文件保存在 Git

```Bash
D:\Program Files\Git\mingw64\bin
```

- 使用方式

```Bash
$ chrome index.html  # 即可用Chrome浏览器打开html文件
```

过滤掉不需要提交到远程仓库的文件

```.gitignore
/node_modules
.vscode
```

## Tree 命令集

```Bash
-a 显示所有文件和目录。
-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。
-C 在文件和目录清单加上色彩，便于区分各种类型。
-d 显示目录名称而非内容。
-D 列出文件或目录的更改时间。
-f 在每个文件或目录之前，显示完整的相对路径名称。
-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上"*","/","=","@","|"号。
-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。
-i 不以阶梯状列出文件或目录名称。
-I 不显示符合范本样式的文件或目录名称。
-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。
-n 不在文件和目录清单加上色彩。
-N 直接列出文件和目录名称，包括控制字符。
-p 列出权限标示。
-P 只显示符合范本样式的文件或目录名称。
-q 用"?"号取代控制字符，列出文件和目录名称。
-s 列出文件或目录大小。
-t 用文件和目录的更改时间排序。
-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。
-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。
------------------------------
usage: tree [-adfghilnpqrstuvxACDFNS] [-H baseHREF] [-T title ] [-L level [-R]]
    [-P pattern] [-I pattern] [-o filename] [--version] [--help] [--inodes]
    [--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset]
    [--filelimit #] [<directory list>]
  -a            All files are listed.
  -d            List directories only.
  -l            Follow symbolic links like directories.
  -f            Print the full path prefix for each file.
  -i            Don't print indentation lines.
  -q            Print non-printable characters as '?'.
  -N            Print non-printable characters as is.
  -p            Print the protections for each file.
  -u            Displays file owner or UID number.
  -g            Displays file group owner or GID number.
  -s            Print the size in bytes of each file.
  -h            Print the size in a more human readable way.
  -D            Print the date of last modification.
  -F            Appends '/', '=', '*', or '|' as per ls -F.
  -v            Sort files alphanumerically by version.
  -r            Sort files in reverse alphanumeric order.
  -t            Sort files by last modification time.
  -x            Stay on current filesystem only.
  -L level      Descend only level directories deep.
  -A            Print ANSI lines graphic indentation lines.
  -S            Print with ASCII graphics indentation lines.
  -n            Turn colorization off always (-C overrides).
  -C            Turn colorization on always.
  -P pattern    List only those files that match the pattern given.
  -I pattern    Do not list files that match the given pattern.
  -H baseHREF   Prints out HTML format with baseHREF as top directory.
  -T string     Replace the default HTML title and H1 header with string.
  -R            Rerun tree when max dir level reached.
  -o file       Output to file instead of stdout.
  --inodes      Print inode number of each file.
  --device      Print device ID number to which each file belongs.
  --noreport    Turn off file/directory count at end of tree listing.
  --nolinks     Turn off hyperlinks in HTML output.
  --dirsfirst   List directories before files.
  --charset X   Use charset X for HTML and indentation line output.
  --filelimit # Do not descend dirs with more than # files in them.
```
